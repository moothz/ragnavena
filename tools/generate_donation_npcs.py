import sqlite3
import json
import random
import os
import sys
import subprocess
import time
from datetime import datetime

DB_PATH = '/home/moothz/ravena-ai/data/sqlites/core.db'
NPC_FILE = 'rAthena/npc/custom/ravena_donations.txt'
CONF_FILE = 'rAthena/npc/scripts_custom.conf'
MAP_NAME = 'darkmall'

CUSTOM_SPRITES = {
    'Eduardo C.': 476,
    'Audrey Nunes': 747
}

def get_tier1_coords():
    # (95,147) -> (104, 147)
    # Start, End, alternating inward. 1 space gap.
    # Available X: 95, 96, 97, 98, 99, 100, 101, 102, 103, 104
    # Occupied: 95, 104, 97, 102, 99, 101 (if following pattern)
    # Pattern: left, right, left+2, right-2 ...
    left = 95
    right = 104
    while left < right:
        yield (left, 147)
        left += 2 # Gap 1
        if left > right: break
        
        yield (right, 147)
        right -= 2 # Gap 1

def get_tier2_coords():
    # Left: (95, Y) -> (68, Y). Right to Left. Gap 1.
    # Right: (104, Y) -> (131, Y). Left to Right. Gap 1.
    # Rows: 132, 126 (Use 126 after 132 is exhausted)
    
    for y in [132, 126]:
        l_start = 95
        l_end = 68
        r_start = 104
        r_end = 131
        
        # We iterate until one side runs out (or both)
        curr_l = l_start
        curr_r = r_start
        
        while curr_l >= l_end or curr_r <= r_end:
            if curr_l >= l_end:
                yield (curr_l, y)
                curr_l -= 2
            
            if curr_r <= r_end:
                yield (curr_r, y)
                curr_r += 2

def get_tier3_coords():
    # Left Col: 60, 61, 62
    # Right Col: 138, 137, 136
    # Vertical spacing: 2 blocks (130, 128, ...)
    
    y_start = 130
    y_end = 62
    
    for y in range(y_start, y_end - 1, -2):
        # Order: Yield all 3 left, then all 3 right? Or alternating?
        # "Alternating each one" was old instruction. 
        # I'll alternate pairs for visual balance? Or just list them.
        
        # Left side
        yield (60, y)
        yield (61, y)
        yield (62, y)
        
        # Right side
        yield (138, y)
        yield (137, y)
        yield (136, y)

def generate_npcs():
    if not os.path.exists(DB_PATH):
        print(f"Error: Database not found at {DB_PATH}")
        return

    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        cursor.execute("SELECT name, json_data FROM donations")
        rows = cursor.fetchall()
        conn.close()
    except Exception as e:
        print(f"Error reading database: {e}")
        return

    donations = []
    for name, json_str in rows:
        try:
            data = json.loads(json_str)
            valor = data.get('valor', 0)
            if valor >= 5:
                donations.append({'name': name, 'data': data, 'valor': valor})
        except:
            continue

    # Sort by valor descending
    donations.sort(key=lambda x: x['valor'], reverse=True)

    tier1 = [] # > 199
    tier2 = [] # 34 < valor < 200 (so 35..199)
    tier3 = [] # < 35 (and >= 5)

    for d in donations:
        v = d['valor']
        if v > 199:
            tier1.append(d)
        elif v > 34:
            tier2.append(d)
        else:
            tier3.append(d)

    # Sprites
    # Tier 1: Fixed pool, draw without replacement
    t1_sprites = [2077, 2078, 1870, 1263, 1739, 421, 466, 367, 368, 469, 470, 615, 616]
    random.shuffle(t1_sprites)
    
    # Tier 2: 1634..1663
    t2_sprites = list(range(1634, 1651))
    
    # Tier 3: 589-600 + [1966, 1967]
    t3_sprites = list(range(589, 601)) + [1966, 1967]
    
    content = "// Generated by tools/generate_donation_npcs.py\n"
    
    # Process Tier 1
    t1_gen = get_tier1_coords()
    for d in tier1:
        try:
            x, y = next(t1_gen)
            if d['name'] in CUSTOM_SPRITES:
                sprite = CUSTOM_SPRITES[d['name']]
            elif t1_sprites:
                sprite = t1_sprites.pop()
            else:
                sprite = 0 # Fallback
                print(f"Warning: Run out of unique sprites for Tier 1 donor {d['name']}")
                
            content += create_npc_script(d, x, y, sprite)
        except StopIteration:
            print("Warning: Out of space for Tier 1 donations")
            break

    # Process Tier 2
    t2_gen = get_tier2_coords()
    for d in tier2:
        try:
            x, y = next(t2_gen)
            if d['name'] in CUSTOM_SPRITES:
                sprite = CUSTOM_SPRITES[d['name']]
            else:
                sprite = random.choice(t2_sprites)
            content += create_npc_script(d, x, y, sprite)
        except StopIteration:
            print("Warning: Out of space for Tier 2 donations")
            break

    # Process Tier 3
    t3_gen = get_tier3_coords()
    for d in tier3:
        try:
            x, y = next(t3_gen)
            if d['name'] in CUSTOM_SPRITES:
                sprite = CUSTOM_SPRITES[d['name']]
            else:
                sprite = random.choice(t3_sprites)
            
            content += create_npc_script(d, x, y, sprite)
        except StopIteration:
            print("Warning: Out of space for Tier 3 donations")
            break

    # Write file
    try:
        with open(NPC_FILE, 'w', encoding='iso-8859-1') as f:
            f.write(content)
        print(f"Successfully wrote {len(donations)} NPCs to {NPC_FILE}")
    except Exception as e:
        print(f"Error writing NPC file: {e}")
        return

    # Check config
    check_and_update_conf()

    # Ask for restart
    ask_restart()

def create_npc_script(donation, x, y, sprite):
    name = sanitize_for_iso(donation['name'])
    valor = donation['valor']
    data = donation['data']
    history = data.get('historico', [])
    
    # Escape quotes in name just in case
    safe_name = name.replace('"', '\\"')
    
    script = f'{MAP_NAME},{x},{y},4\tscript\t{safe_name}\t{sprite},{{\n'
    script += f'\tmes "[^0000FF{safe_name}^000000]";\n'
    script += f'\tmes "Total: ^FF0000{valor}^000000";\n'
    script += '\tmes "Historico:";\n'
    
    # Sort history by ts descending
    history.sort(key=lambda h: h.get('ts', 0), reverse=True)
    
    for h in history:
        ts = h.get('ts', 0)
        val = h.get('valor', 0)
        # TS is likely ms, convert to date
        try:
            dt = datetime.fromtimestamp(ts / 1000)
            date_str = dt.strftime('%d/%m/%Y')
        except:
            date_str = "Um dia qualquer"
        
        script += f'\tmes "^009900{date_str}^000000: {val}";\n'
    
    script += '\tclose;\n'
    script += '}\n\n'
    return script

def sanitize_for_iso(text):
    # Ensure text is safe for ISO-8859-1
    return text.encode('iso-8859-1', 'replace').decode('iso-8859-1')

def check_and_update_conf():
    if not os.path.exists(CONF_FILE):
        print(f"Config file {CONF_FILE} not found.")
        return

    with open(CONF_FILE, 'r') as f:
        lines = f.readlines()
    
    entry = "npc: npc/custom/ravena_donations.txt"
    found = False
    for line in lines:
        if entry in line:
            found = True
            break
    
    if not found:
        print(f"Adding {entry} to {CONF_FILE}")
        with open(CONF_FILE, 'a') as f:
            if lines and not lines[-1].endswith('\n'):
                f.write('\n')
            f.write(f"{entry}\n")
    else:
        print(f"Config {CONF_FILE} already has entry.")

def ask_restart():
    print("\nNPC generation complete.")
    print("Do you want to restart 'ragnavena-game' service now? (y/n)")
    try:
        choice = input().strip().lower()
        if choice == 'y':
            print("Restarting service...")
            subprocess.run(['sudo', 'systemctl', 'restart', 'ragnavena-game'], check=True)
            print("Service restarted.")
        else:
            print("Skipping restart.")
    except Exception as e:
        print(f"Error restarting service: {e}")

if __name__ == '__main__':
    generate_npcs()
